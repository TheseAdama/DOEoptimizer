#' @title Genetic Evolutionary Algorithm Optimization Method
#'
#' @description
#' The `GEAoptim` function implements a genetic algorithm for optimizing a given objective function.
#' The algorithm is designed to operate within the context of design of experiments.
#' The function supports both maximization and minimization of the objective function.
#'
#' @param fobj A function representing the objective function to be optimized. It should accept a matrix as input where each row is a different set of design.
#' @param size An integer specifying the number of points in each population (i.e., the population size).
#' @param D A matrix where each row specifies the lower and upper bounds for each dimension of the design space.
#' @param maxiter An integer specifying the maximum number of iterations (generations) for the genetic algorithm. Default is 1000.
#' @param Np An integer specifying the number of individuals in the population. Default is 100.
#' @param ps A numeric value between 0 and 1 specifying the proportion of the population to be selected for breeding (selection rate). Default is 0.5.
#' @param pm A numeric value between 0 and 1 specifying the mutation probability. Default is 0.1.
#' @param isMax A logical value indicating whether the objective function should be maximized (`TRUE`) or minimized (`FALSE`). Default is `TRUE`.
#' @details
#' The genetic algorithm works by iteratively evolving a population of candidate solutions to an optimization problem.
#' In each iteration (generation), the following steps are performed:
#'
#' 1. **Initialization**: The population is initialized with random solutions within the bounds specified by `D`.
#' 2. **Evaluation**: Each individual in the population is evaluated using the objective function.
#' 3. **Selection**: A subset of the population is selected based on their fitness (objective function value).
#' 4. **Crossover**: New individuals (offspring) are generated by combining parts of selected individuals (parents).
#' 5. **Mutation**: Some individuals undergo random mutations to introduce diversity.
#' 6. **Replacement**: The old population is replaced with the new one, and the process repeats.
#'
#' The algorithm stops after a specified number of iterations or when convergence criteria are met.
#' The best solution found during the process is returned as the result.
#'
#' @return
#' The function returns a list contain:
#' \item{Xopt}{The optimal design matrix found by the algorithm.}
#' \item{Copt}{The corresponding objective function value at the optimal design.}
#'
#' @examples
#' \dontrun{
#' # Define the objective function
#' fobj <- function(X){return(log(det(t(X)%*%X)))}
#'
#' # Define the design space
#' D <- matrix(c(0, 10, 0, 5), ncol = 2, byrow = TRUE)
#'
#' # Run the genetic algorithm optimization
#' R <- GEAoptim(fobj, size=10, D=D, maxiter=1000, Np=1000, ps=0.25, pm=0.25, isMax=TRUE)
#'
#' # Access the results
#' print(R$Xopt)
#' print(R$Copt)
#' }
#'
#' @references
#' - Huan, Xun and Marzouk, Youssef M, "Simulation-based optimal Bayesian experimental
#'   design for nonlinear systems", Journal of Computational Physics (2013), 288-317.
#' - J. C. Spall, "An overview of the simultaneous perturbation method for efficient
#'   optimization", Johns Hopkins APL Technical Digest 19 (1998) 482-492.
#' - N. L. Kleinman, J. C. Spall, D. Q. Naiman, "Simulation-based optimization with
#'   stochastic approximation using common random numbers", Management Science
#'   45 (1999) 1570-1578.
#' - J. C. Spall, "Multivariate stochastic approximation using a simultaneous perturbation gradient approximation", IEEE Transactions on Automatic Control 37
#'   (1992) 332-341.
#'
#' @export
GEAoptim <- function(fobj,  size, D, maxiter, Np,
                     ps=0.5, pm=0.1, isMax=TRUE){

  if(is.null(maxiter)){
    maxiter <- if(nrow(D) < 4) {10^(1 + nrow(D)) } else {10^4}
  }
  if(is.null(Np)) Np = 100*nrow(D)
  if (!is.numeric(maxiter)) stop("maxiter must be numeric")
  if (!is.numeric(size)) stop("size must be numeric")
  if (!is.logical(isMax)) stop("isMax must be logical (TRUE or FALSE)")
  if (!is.matrix(D) || ncol(D) != 2) stop("D must be a 2-column matrix")
  if (!is.numeric(Np)) stop("Np must be numeric")
  if (!is.numeric(ps) || (ps > 1 || ps < 0)) stop("The percentage of selection 'ps' must be a numeric between 0 and 1")
  if (!is.numeric(pm) || (pm > 1 || pm < 0)) stop("The probability of mutation 'pm' must be a numeric between 0 and 1")

  d <- nrow(D)
  Pop <- array(0, dim = c(size, d, Np))
  for(i in 1:Np){
    Pop[ , ,i] <- matrix(stats::runif(size*d, min=D[,1], max=D[,2]),
                         nrow = size, byrow=TRUE)
  }
  hh = rep(0, maxiter)
  for(k in 1:maxiter){
    fP <- apply(Pop, 3, fobj)
    ind <- sort.int(fP, decreasing = isMax, index.return = TRUE)$ix
    Nsel <- round(Np * ps)
    PopS <- Pop[, , ind[1:Nsel]]

    for(j in (Nsel + 1):Np){
      parents <- sample(1:Nsel, 2, replace = FALSE)
      crossover_point <- sample(1:(size-1), 1)
      Pop[ , , j] <- rbind(PopS[1:crossover_point, , parents[1]],
                           PopS[(crossover_point+1):size, , parents[2]])
    }

    for(i in 1:Np){
      if(stats::runif(1) < pm){
        mind <- sample(1:(size*d), 1)
        row <- ceiling(mind / d)
        col <- mind %% d
        Pop[row, col, i] <- stats::runif(1, min=D[col,1], max=D[col,2])
      }
    }

    if(k %% 10 == 0){
      cat(sprintf("Progress: %.2f%%\n", (k / maxiter) * 100))
    }
    hh[k] <- fP[ind[1]]
  }
  plot(c(1:maxiter), hh, main="History GE",xlab="Iteration",
       ylab="fobj", lwd=1.5, type='l', col="blue", cex.axis=1.5, cex.lab=1.5, cex.main=1.8)


  fP <- apply(Pop, 3, fobj)
  ind <- sort.int(fP, decreasing = isMax, index.return = TRUE)$ix

  Xopt <- Pop[, , ind[1]]
  Copt <- fP[ind[1]]
  return(list(Xopt=Xopt, Copt=Copt))
}
